#warn: should the function itself warn about violations -- alternatively, can use check_expections()
expect_range <- function(data, value_pairs, na_accept = FALSE, warn = FALSE){
#Create a expectation column for each supplied column.
temp <- map(seq_along(value_pairs), function(x){
temp_col <- names(value_pairs)[x]
temp_min <- value_pairs[[x]][1]
temp_max <- value_pairs[[x]][2]
#Handle either date or number - better way?
if (is.na(lubridate::ymd(temp_min))){
temp_min <- as.numeric(temp_min)
temp_max <- as.numeric(temp_max)
}
if(!is.na(lubridate::ymd(temp_min))){
temp_min <- lubridate::ymd(temp_min)
temp_max <- lubridate::ymd(temp_max)
}
#Stop if max or min is missing. Cannot supply just one.
#If one of them is not desired, can supply a very low or high artificial value.
if (is.na(temp_max) | is.na(temp_min)){
stop(str_c(temp_col, ": Missing minimum or maximum value. Check that supplied format was numeric or YMD."))
}
#Stop if max is not greater than min
if (temp_max <= temp_min){
stop(str_c(temp_col, ": Maximum value must be greater than minimum."))
}
meta_col <- data |>
mutate("exp_{temp_col}_range" := if_else(!!sym(temp_col) >= temp_min & !!sym(temp_col) <= temp_max, TRUE, FALSE), .keep = "none") |>
#convert NA to TRUE or FALSE depending on argument
mutate(across(everything(), ~ if_else(is.na(.), as.logical(na_accept), .)))
#If warn is true, print out number of violations
if (warn == TRUE){
viols <- nrow(filter(meta_col, !!sym(names(meta_col)[1]) == FALSE))
print(str_c(viols, " ", if_else(viols == 1, "violation", "violations"), " of the expected *RANGE* in *", temp_col, "*"))
}
return(meta_col)
})
#Add new columns to the data
return(cbind(data, temp))
}
#Example
test_data |>
expect_range(list(age = c(0, 100)),
na_accept = TRUE,
warn = TRUE) |>
view()
#Example
test_data |>
expect_range(list(age = c(0, 100)),
na_accept = TRUE,
warn = TRUE) |>
view()
#This is the only one where the column is the list item (kind of confusing) but it wouldn't work well the other way
#data: a dataframe with data to validate
#value_pairs: a list where names are column types and values are columns
#warn: should the function itself warn about violations -- alternatively, can use check_expections()
type_list <- list(character = c("id", "zip"),
numeric = c("age"),
date = "test_date")
expect_type <- function(data, value_pairs, warn = FALSE){
#Loop through each type
temp <- map(seq_along(value_pairs), function(t){
temp_type <- str_to_lower(names(value_pairs)[t])
temp_type <- if_else(temp_type == "date", "Date", temp_type)
#Stop if type is not in the intended list
if (!temp_type %in% c("numeric", "character", "Date", "logical", "factor")){
stop("Accepted column types are: character, date, factor, logical, numeric.")
}
#Within each type, loop through and evalute each column
meta_col <- map(seq_along(value_pairs[[t]]), function(c){
temp_col <- value_pairs[[t]][[c]]
dname <- deparse(substitute(data)) #get input df name in text
#The code below will test whether the column is the correct type
type_test <- eval(parse(text = paste0(if_else(temp_type == "Date", "lubridate::is.", "is."),
temp_type, "(", dname, "$", temp_col, ")")))
cname <- paste0("exp_", temp_col, "_type") #define exp_column name
log_value <- tibble(!!sym(cname) := rep(type_test, nrow(data))) #create named tibble (returned as part of a list)
#If warn is TRUE, notify of violations
if (warn == TRUE & log_value[1,1] == FALSE){
print(paste0("Expectation violated: *", temp_col, "* is not *", str_to_upper(temp_type), "* type"))
}
return(log_value)
})
})
#Combine all column-T/F pairs into a single dataframe, combine w/ data
return(bind_cols(data, bind_cols(temp)))
}
#Example
test_data |>
expect_type(type_list,
warn = TRUE) |>
view()
#data: a dataframe with at least one metadata column created by the "expect_" functions
#fail: should violations result in an error? Default is TRUE.
#export: should a dataframe (violations_export) of violations (up to 1,000) be created? Default is TRUE
#export_keep: by default the violations dataframe will keep any metadata columns with violations and the corresponding data. Here, specify any additional columns that should be retained (such as a unique ID). Default is NULL.
check_expectations <- function(data, fail = TRUE, export = TRUE, export_keep = NULL){
#Fail if there are no expectation columns
if (length(names(data)[str_detect(names(data), "^exp_")]) == 0){
stop("No expectation columns in the dataframe. Generate these using an 'expect_' function.")
}
#Print relevant validation information.
print(str_c("Validating data using ", length(names(data)[str_detect(names(data), "^exp_")]), " conditions."))
#Identify invalid values
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~ is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
#Only keep relevant non-'exp' columns as well
ckeep <- names(violations)[str_detect(names(violations), "^exp_")] |>
str_remove_all("exp_|_\\w*$")
violations <- violations |>
select(starts_with("exp_"), all_of(ckeep), all_of(export_keep)) #also add in anything specified in export_keep
#If there are no violations, return a DF along with an appropriate message
if (nrow(violations) == 0){
print("All expectations satisfied. Validation successful.")
return(data |> select(-starts_with("exp_"))) #remove metadata columns
}
#The remaining code handles cases where there are violations.
#Print violations
vnames <- names(violations)[str_detect(names(violations), "^exp_")]
walk(vnames, function(x){
nme <- str_remove(x, "exp_")
coln <- str_remove(nme, "_.*$")
vtype <- str_remove(nme, str_c(coln, "_"))
#Get number of violations for each condition
vnum <- violations |>
select(all_of(x)) |>
filter(!!sym(x) == FALSE) |>
nrow()
print(str_c(vnum, " ", if_else(vnum == 1, "violation", "violations"), " of the expected *", str_to_upper(vtype), "* in *", coln, "*"))
})
#Export up to the first 1,000 violations if export == TRUE
if (export == TRUE){
violations_export <- violations |>
slice(1:1000)
#exp_name <- str_c(deparse(substitute(data)), "_violations")
assign("violations_export", violations_export, envir = globalenv())
print("Up to the first 1,000 violations written to *violations_export* dataframe.")
}
#Stop or return data based on failure preference
if (fail == TRUE){
stop("Violations flagged. Data validation failed.")
} else if (fail == FALSE){
print("Violations flagged. Review output data.")
return(data |> select(-starts_with("exp_")))
}
}
#Since fail = FALSE, this will allow the dataframe to pass through with warnings about the violations.
test_data |>
expect_values(list(sex = c("M", "F", "U"),
county = "Hennepin"),
na_accept = TRUE) |>
expect_range(list(age = c(0, 100)),
na_accept = TRUE) |>
expect_format(list(id = "^MN\\-\\d*$")) |>
expect_type(list(character = c("id", "zip"),
numeric = c("age"),
date = "test_date")) |>
expect_missing(list(id = 0,
county = 0.15)) |>
check_expectations(fail = FALSE, export_keep = "id") |>
view()
test_data |>
expect_values(list(sex = c("M", "F", "U"),
county = "Hennepin"),
na_accept = TRUE) |>
expect_range(list(age = c(0, 100)),
na_accept = TRUE) |>
expect_format(list(id = "^MN\\-\\d*$")) |>
expect_type(list(character = c("id", "zip"),
numeric = c("age"),
date = "test_date")) |>
expect_missing(list(id = 0,
county = 0.15))
test_data |>
expect_values(list(sex = c("M", "F", "U"),
county = "Hennepin"),
na_accept = TRUE) |>
expect_range(list(age = c(0, 100)),
na_accept = TRUE) |>
expect_format(list(id = "^MN\\-\\d*$")) |>
expect_type(list(character = c("id", "zip"),
numeric = c("age"),
date = "test_date")) |>
expect_missing(list(id = 0,
county = 0.15)) |>
check_expectations(fail = FALSE, export_keep = "id")
#Since fail = FALSE, this will allow the dataframe to pass through with warnings about the violations.
test_data |>
expect_values(list(sex = c("M", "F", "U"),
county = "Hennepin"),
na_accept = TRUE) |>
#expect_range(list(age = c(0, 100)),
#             na_accept = TRUE) |>
#expect_format(list(id = "^MN\\-\\d*$")) |>
#expect_type(list(character = c("id", "zip"),
#                numeric = c("age"),
#                date = "test_date")) |>
#expect_missing(list(id = 0,
#                       county = 0.15)) |>
check_expectations(fail = FALSE, export_keep = "id") |>
view()
#Since fail = FALSE, this will allow the dataframe to pass through with warnings about the violations.
test_data |>
#expect_values(list(sex = c("M", "F", "U"),
#                   county = "Hennepin"),
#               na_accept = TRUE) |>
expect_range(list(age = c(0, 100)),
na_accept = TRUE) |>
expect_format(list(id = "^MN\\-\\d*$")) |>
#expect_type(list(character = c("id", "zip"),
#                numeric = c("age"),
#                date = "test_date")) |>
#expect_missing(list(id = 0,
#                       county = 0.15)) |>
check_expectations(fail = FALSE, export_keep = "id") |>
view()
#data: a dataframe with at least one metadata column created by the "expect_" functions
#fail: should violations result in an error? Default is TRUE.
#export: should a dataframe (violations_export) of violations (up to 1,000) be created? Default is TRUE
#export_keep: by default the violations dataframe will keep any metadata columns with violations and the corresponding data. Here, specify any additional columns that should be retained (such as a unique ID). Default is NULL.
check_expectations <- function(data, fail = TRUE, export = TRUE, export_keep = NULL){
#Fail if there are no expectation columns
if (length(names(data)[str_detect(names(data), "^exp_")]) == 0){
stop("No expectation columns in the dataframe. Generate these using an 'expect_' function.")
}
#Print relevant validation information.
print(str_c("Validating data using ", length(names(data)[str_detect(names(data), "^exp_")]), " conditions."))
#Identify invalid values
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~ is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
#Only keep relevant non-'exp' columns as well
ckeep <- names(violations)[str_detect(names(violations), "^exp_")] |>
str_remove_all("exp_|_\\w*$")
violations <- violations |>
select(starts_with("exp_"), all_of(ckeep), all_of(export_keep)) #also add in anything specified in export_keep
#If there are no violations, return a DF along with an appropriate message
if (nrow(violations) == 0){
print("All expectations satisfied. Validation successful.")
return(data |> select(-starts_with("exp_"))) #remove metadata columns
}
#The remaining code handles cases where there are violations.
#Print violations
vnames <- names(violations)[str_detect(names(violations), "^exp_")]
walk(vnames, function(x){
nme <- str_remove(x, "exp_")
coln <- str_remove(nme, "_.*$")
vtype <- str_remove(nme, str_c(coln, "_"))
#Get number of violations for each condition
vnum <- violations |>
select(all_of(x)) |>
filter(!!sym(x) == FALSE) |>
nrow()
print(str_c(vnum, " ", if_else(vnum == 1, "violation", "violations"), " of the expected *", str_to_upper(vtype), "* in *", coln, "*"))
})
#Export up to the first 1,000 violations if export == TRUE
if (export == TRUE){
violations_export <- violations |>
slice(1:1000)
#exp_name <- str_c(deparse(substitute(data)), "_violations")
assign("violations_export", violations_export, envir = globalenv())
print("Up to the first 1,000 violations written to *violations_export* dataframe.")
}
#Stop or return data based on failure preference
if (fail == TRUE){
stop("Violations flagged. Data validation failed.")
} else if (fail == FALSE){
print("Violations flagged. Review output data.")
return(data |> select(-starts_with("exp_")))
}
}
#Since fail = FALSE, this will allow the dataframe to pass through with warnings about the violations.
test_data |>
expect_values(list(sex = c("M", "F", "U"),
county = "Hennepin"),
na_accept = TRUE) |>
expect_range(list(age = c(0, 100)),
na_accept = TRUE) |>
expect_format(list(id = "^MN\\-\\d*$")) |>
expect_type(list(character = c("id", "zip"),
numeric = c("age"),
date = "test_date")) |>
expect_missing(list(id = 0,
county = 0.15)) |>
check_expectations(fail = FALSE, export_keep = "id") |>
view()
#Since fail = FALSE, this will allow the dataframe to pass through with warnings about the violations.
test_data |>
expect_values(list(sex = c("M", "F", "U"),
county = "Hennepin"),
na_accept = TRUE) |>
#expect_range(list(age = c(0, 100)),
#             na_accept = TRUE) |>
#expect_format(list(id = "^MN\\-\\d*$")) |>
#expect_type(list(character = c("id", "zip"),
#                numeric = c("age"),
#                date = "test_date")) |>
#expect_missing(list(id = 0,
#                       county = 0.15)) |>
#check_expectations(fail = FALSE, export_keep = "id") |>
view()
data <- test_data |>
expect_values(list(sex = c("M", "F", "U"),
county = "Hennepin"),
na_accept = TRUE)
View(data)
data |>
check_expectations()
data <- test_data |>
expect_values(list(sex = c("M", "F", "U"),
county = "Hennepin"),
na_accept = TRUE)
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~ is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) #|>
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
#select(!starts_with("exp_") | where(~ is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
#select(!starts_with("exp_") | where(~ is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
View(violations)
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_")) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
View(violations)
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~ starts_with("exp_") && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
?all
all(c(TRUE, TRUE, FALSE))
all(c(TRUE, TRUE))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~ is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(where(~ is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(\(x) is.logical(x) && !all(x))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
#select(!starts_with("exp_") | where(~ is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~ is.logical(.) & !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
TRUE & FALSE
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~ !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.) && all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
all(data$exp_sex_value)
all(data$exp_county_value)
TRUE && FALSE
is.logical(data$exp_sex_value) && !all(data$exp_sex_value)
is.logical(data$exp_sex_value) & !all(data$exp_sex_value)
where(is.logical(data$exp_sex_value) && !all(data$exp_sex_value))
where(~is.logical(.) && !all(.))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | (~is.logical(.) && !all(.)) == TRUE) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(is.logical())) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
select(!starts_with("exp_") | where(is.logical) |> #remove exp_ columns with no violations
select(!starts_with("exp_") | where(is.logical & all) |> #remove exp_ columns with no violations
violations <- data |>
)
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(is.logical & all)) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical & all)) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.) & all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.) && all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.) && ~all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.) & ~all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.) && !all(.))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~is.logical(.) && !all(., na.rm = TRUE))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
mutate(exp_county_value = TRUE) |>
select(!starts_with("exp_") | where(~is.logical(.) && !all(., na.rm = TRUE))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
#data: a dataframe with at least one metadata column created by the "expect_" functions
#fail: should violations result in an error? Default is TRUE.
#export: should a dataframe (violations_export) of violations (up to 1,000) be created? Default is TRUE
#export_keep: by default the violations dataframe will keep any metadata columns with violations and the corresponding data. Here, specify any additional columns that should be retained (such as a unique ID). Default is NULL.
check_expectations <- function(data, fail = TRUE, export = TRUE, export_keep = NULL){
#Fail if there are no expectation columns
if (length(names(data)[str_detect(names(data), "^exp_")]) == 0){
stop("No expectation columns in the dataframe. Generate these using an 'expect_' function.")
}
#Print relevant validation information.
print(str_c("Validating data using ", length(names(data)[str_detect(names(data), "^exp_")]), " conditions."))
#Identify invalid values
violations <- data |>
filter(if_any(starts_with("exp_"), ~ . == FALSE)) |>
select(!starts_with("exp_") | where(~ is.logical(.) && !all(., na.rm = TRUE))) |> #remove exp_ columns with no violations
relocate(starts_with("exp_"))
#Only keep relevant non-'exp' columns as well
ckeep <- names(violations)[str_detect(names(violations), "^exp_")] |>
str_remove_all("exp_|_\\w*$")
violations <- violations |>
select(starts_with("exp_"), all_of(ckeep), all_of(export_keep)) #also add in anything specified in export_keep
#If there are no violations, return a DF along with an appropriate message
if (nrow(violations) == 0){
print("All expectations satisfied. Validation successful.")
return(data |> select(-starts_with("exp_"))) #remove metadata columns
}
#The remaining code handles cases where there are violations.
#Print violations
vnames <- names(violations)[str_detect(names(violations), "^exp_")]
walk(vnames, function(x){
nme <- str_remove(x, "exp_")
coln <- str_remove(nme, "_.*$")
vtype <- str_remove(nme, str_c(coln, "_"))
#Get number of violations for each condition
vnum <- violations |>
select(all_of(x)) |>
filter(!!sym(x) == FALSE) |>
nrow()
print(str_c(vnum, " ", if_else(vnum == 1, "violation", "violations"), " of the expected *", str_to_upper(vtype), "* in *", coln, "*"))
})
#Export up to the first 1,000 violations if export == TRUE
if (export == TRUE){
violations_export <- violations |>
slice(1:1000)
#exp_name <- str_c(deparse(substitute(data)), "_violations")
assign("violations_export", violations_export, envir = globalenv())
print("Up to the first 1,000 violations written to *violations_export* dataframe.")
}
#Stop or return data based on failure preference
if (fail == TRUE){
stop("Violations flagged. Data validation failed.")
} else if (fail == FALSE){
print("Violations flagged. Review output data.")
return(data |> select(-starts_with("exp_")))
}
}
#Since fail = FALSE, this will allow the dataframe to pass through with warnings about the violations.
test_data |>
expect_values(list(sex = c("M", "F", "U"),
county = "Hennepin"),
na_accept = TRUE) |>
expect_range(list(age = c(0, 100)),
na_accept = TRUE) |>
expect_format(list(id = "^MN\\-\\d*$")) |>
expect_type(list(character = c("id", "zip"),
numeric = c("age"),
date = "test_date")) |>
expect_missing(list(id = 0,
county = 0.15)) |>
check_expectations(fail = FALSE, export_keep = "id") |>
view()
#This dataframe is created to review the errors
violations_export #|>
#display()
